Para parsear projetos standalone - https://www.programcreek.com/2011/01/a-complete-standalone-example-of-astparser/

TODO
Prioridade 2: Testar calculo das interface excepcional com finally. try-finally(throw) e try-finally(return)
OK Prioridade 1: refatorar MethodNode: criar classe ExceptionalInterface, com relação 1:1 com MethodNode.
OK Prioridade 1: ExceptionalInterface deve ter uma lista de EIType, que por sua vez possui um ITypeBinding ou um IType. Implementas equals do EIType.
Prioridade 1: Refatorar ExceptionalInterface para armazenar origem do fluxo. Pode ser armazenado no IMethod + linha de código. Reimplementar equals e hashCode. Trocar EIType por EISignaler, que tem o tipo e origem.
Prioridade 2: Diferenciar cada sinalização: trocar Set por List em ExceptionalInterface.


OBSERVAÇÕES
Para parsear o método, é preciso que o código-fonte dele esteja disponível.
	Aplicação: o código da própria aplicação é obviamente garantido.
	Java: Código java é parcialmente garantido, porque alguns pacotes são proprietários e não há fonte para eles.
	Dependencias: É comum que o código fonte de dependencias gradle sejam baixados e linkados automaticamente. Não sei do Maven e outros.
	A recomendação é: usuário, faça de tudo para ter o código fonte de todas as dependencias. Se o código não existir, a análise levará em consideração somente a interface excepcional declarada, o que é péssimo. Como se sabe, todo esse trabalho é motivado pelo fato das interfaces excepcionais declaradas serem incompletas e imprecisas.
		  O que se pode fazer nesse caso é adicionar uma análise dinâmica. Especialmente para os métodos sem fonte, qualquer ocorrência de exceção é verificada e adicionada à base de dados.
Métodos native são um problema. Não existe código para eles!
	Confiar somente na declaração
		Adicionar no DB se encontrar exceção em runtime.
Métodos que não puderam ser parseados (ver itens acima) levam a interface excepcional declarada consigo e um tipo especial de exceção (ou marcação) que indica que ele não foi parseado.  			
Limitações
	Ver classe IndirectRecursion
	Ver classe AnonymousClasses
	Ver classe InterfaceResolution


ALGORITMO - Abrir classe no editor
Inicia o visitor callee
	Para cada método
		visit
			Verificar se já foi visitado
				Sim
					return false (ainda assim será chamado postVisitor para este método. Os seus filhos é que não vão ser visitados)
				Não
					return true
		Post visit
			parsear o código
				Para cada chamada de método
					Verificar a interface excepcional daquele método
						Há exceções?
							Sim
								A chamada está em um try?
									Sim
										Marcar a chamada com @throws
										
										Verificar se as exceções são capturadas
											Sim
												Verificar se a exceção é encapsulada e relançada
													Sim
														Adicionar a exceção no "remaps" do método
													Não
														Adicionar a exceção no "catches" do método
											Não
												Adicionar as exceções no "rethrows" do método
									Não
										Adicionar as exceções no "rethrows" do método
							Não
								Nada a fazer
				Para cada throw que não está em um catch e nem em um try
					Adicionar a exceção no "throws" do método
			Marcar como visitado
				

ALGORITMO - Salvar arquivo
Parsear método
	Verificar se a interface excepcional mudou
		Sim
			Iniciar visitor caller
				Para cada método, verificar se a interface mudou
					Sim
						Processar e repetir
					Não
						Finalizar a visita a esse galho
		Não
			Nada a fazer		
			
