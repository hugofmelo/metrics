Para parsear projetos standalone - https://www.programcreek.com/2011/01/a-complete-standalone-example-of-astparser/

TODO
CANCELADO Verificar qual o código fonte de métodos "native"
DONE Implementar callgraph e busca em profundidade
Organizar o código do callgraph, refatorando o que for necessário e comentando tudo
Enriquecer o parser do método (ver algoritmo abaixo)
	throws
	rethrows
	remaps
	catches
Testar (com testes de verdade) se o call graph que eu uso corresponde ao call graph verdadeiro
Idéia: Criar um grafo, de fato, das chamadas. Ver o desempenho.
	Com o grafo, eu posso identificar as chamadas de método individuais (diferente do eclipse, que une chamadas iguais). Além disso, eu posso determinar as exceções por chamada, e talvez até colocar a quantidade de ocorrências distintas de exceções, seguindo a idéia inicial que está na proposta e na classe TraceabilityExample

OBSERVAÇÕES
Para parsear o método, é preciso que o código-fonte dele esteja disponível.
	Aplicação: o código da própria aplicação é obviamente garantido.
	Java: Código java é parcialmente garantido, porque alguns pacotes são proprietários e não há fonte para eles.
	Dependencias: É comum que o código fonte de dependencias gradle sejam baixados e linkados automaticamente. Não sei do Maven e outros.
	A recomendação é: usuário, faça de tudo para ter o código fonte de todas as dependencias. Se o código não existir, a análise levará em consideração somente a interface excepcional declarada, o que é péssimo. Como se sabe, todo esse trabalho é motivado pelo fato das interfaces excepcionais declaradas serem incompletas e imprecisas.
		  O que se pode fazer nesse caso é adicionar uma análise dinâmica. Especialmente para os métodos sem fonte, qualquer ocorrência de exceção é verificada e adicionada à base de dados.
Métodos native são um problema. Não existe código para eles!
	Confiar somente na declaração
		Adicionar no DB se encontrar exceção em runtime.
Métodos que não puderam ser parseados (ver itens acima) levam a interface excepcional declarada consigo e um tipo especial de exceção (ou marcação) que indica que ele não foi parseado.  			
Limitações
	Ver classe IndirectRecursion
	Ver classe AnonymousClasses


ALGORITMO - Abrir classe no editor
Inicia o visitor callee
	Para cada método
		visit
			Verificar se já foi visitado
				Sim
					return false (ainda assim será chamado postVisitor para este método. Os seus filhos é que não vão ser visitados)
				Não
					return true
		Post visit
			parsear o código
				Para cada chamada de método
					Verificar a interface excepcional daquele método
						Há exceções?
							Sim
								A chamada está em um try?
									Sim
										Marcar a chamada com @throws
										
										Verificar se as exceções são capturadas
											Sim
												Verificar se a exceção é encapsulada e relançada
													Sim
														Adicionar a exceção no "remaps" do método
													Não
														Adicionar a exceção no "catches" do método
											Não
												Adicionar as exceções no "rethrows" do método
									Não
										Adicionar as exceções no "rethrows" do método
							Não
								Nada a fazer
				Para cada throw que não está em um catch e nem em um try
					Adicionar a exceção no "throws" do método
			Marcar como visitado
				

ALGORITMO - Salvar arquivo
Parsear método
	Verificar se a interface excepcional mudou
		Sim
			Iniciar visitor caller
				Para cada método, verificar se a interface mudou
					Sim
						Processar e repetir
					Não
						Finalizar a visita a esse galho
		Não
			Nada a fazer		
			